# 詳細設計（抜粋）

- [エラーハンドリングミドルウェア](#エラーハンドリングミドルウェア)
- [asyncHandler](#asyncHandler)
- [トークン認証](#トークン認証)

## エラーハンドリングミドルウェア

アプリケーション全体で発生するエラーを一元的に処理し、統一されたレスポンス形式で返却する。

```
リクエスト
    │
    ▼
┌─────────────────────────────────┐
│  ミドルウェア（JSON parser等）   │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  ルート → コントローラー         │
│         → サービス              │
└─────────────────────────────────┘
    │
    │ エラー発生時
    ▼
┌─────────────────────────────────┐
│  asyncHandler                   │
│  Promise.reject を next() へ    │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  errorHandler（エラーミドルウェア）│
│                                 │
│  ┌───────────────────────────┐  │
│  │ AppError か判定            │  │
│  │ (instanceof でチェック)    │  │
│  └───────────────────────────┘  │
│        │              │         │
│       YES            NO         │
│        │              │         │
│        ▼              ▼         │
│   想定内エラー    想定外エラー    │
│   (404,400等)      (500)        │
└─────────────────────────────────┘
    │
    ▼
統一レスポンス形式で返却
```

### エラーの分類

| 分類         | 説明                             | 例                             | 処理                                  |
| ------------ | -------------------------------- | ------------------------------ | ------------------------------------- |
| 想定内エラー | 開発者が意図的にスローするエラー | NotFoundError, ValidationError | AppError から statusCode, code を取得 |
| 想定外エラー | 予期せず発生するエラー           | DB 接続エラー, TypeError       | 500 で固定レスポンス                  |

## asyncHandler

非同期ルートハンドラーをラップし、エラーを自動的に `next()` に渡すユーティリティ関数。
これによりコントローラーで try-catch が不要になる。

**背景：Express は非同期エラーを自動でキャッチしない**

```typescript
// asyncHandler なし → エラーが握りつぶされる
router.get("/:id", async (req, res) => {
	const task = await getTaskByIdService(req.params.id); // ← エラー発生
	res.json(task);
});
// → レスポンスが返らず、リクエストがタイムアウトする
```

**解決策：asyncHandler でラップ**

```typescript
// asyncHandler あり → エラーが errorHandler へ渡る
router.get(
	"/:id",
	asyncHandler(async (req, res) => {
		const task = await getTaskByIdService(req.params.id); // ← エラー発生
		res.json(task);
	})
);
// → errorHandler で統一レスポンスが返る
```

```
asyncHandler(コントローラー関数)
      │
      ▼
┌─────────────────────────────────────┐
│  新しい関数を返す                     │
│  (req, res, next) => {              │
│    Promise.resolve(fn(...))         │
│      .catch(next);                  │
│  }                                  │
└─────────────────────────────────────┘
      │
      │ リクエスト時に実行
      ▼
┌─────────────────────────────────────┐
│  コントローラー関数を実行             │
└─────────────────────────────────────┘
      │                    │
    成功                  失敗
      │                    │
      ▼                    ▼
  正常レスポンス      .catch(next)
                          │
                          ▼
                   next(error) が呼ばれる
                          │
                          ▼
                   errorHandler へ
```

コントローラーごとに異なる Request 型を使えるようにするため、ジェネリクス型を使用。

```typescript
getTask   → GetTaskRequest    (params: { id: string })
postTask  → CreateTaskRequest (body: { title: string, ... })
patchTask → UpdateTaskRequest (params: { id }, body: { ... })
```

```typescript
export const asyncHandler = <T = Request>(fn: AsyncHandler<T>) => { ... };
//                          ↑ 任意の Request 型を受け取れる

// 使用時に自動で型推論される
router.get("/:id", asyncHandler(getTask));
//                              ↑ T = GetTaskRequest と推論
```

## トークン認証

アクセストークンとリフレッシュトークンを使用した認証フロー。
トークンは httpOnly cookie で管理する。

### トークンの種類

| トークン           | cookie名        | 有効期限 | 用途                     |
| ------------------ | --------------- | -------- | ------------------------ |
| アクセストークン   | `token`         | 1h       | API 認証                 |
| リフレッシュトークン | `refreshToken` | 7d       | アクセストークンの再発行 |

### ログイン時の処理

```
POST /auth/login
    │
    ▼
┌─────────────────────────────────┐
│  認証情報の検証                  │
│  (email/password)               │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  トークン生成                    │
│  ・アクセストークン（1h）        │
│  ・リフレッシュトークン（7d）    │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  リフレッシュトークンをDBに保存   │
│  (User.refreshToken)            │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  httpOnly cookie に設定          │
│  ・token                        │
│  ・refreshToken                 │
└─────────────────────────────────┘
    │
    ▼
レスポンス: { success: true, data: { message: "ログインしました" } }
```

※ 新規登録（POST /auth/register）ではトークンを発行しない。登録後は別途ログインが必要。

### API リクエスト時の認証フロー

```
Client                              Server
   │                                   │
   │  GET /tasks                       │
   │  Cookie: token=xxx                │
   │──────────────────────────────────>│
   │                                   │
   │                          ┌────────┴────────┐
   │                          │ authMiddleware   │
   │                          │ cookie から      │
   │                          │ トークン検証      │
   │                          └────────┬────────┘
   │                                   │
   │                              有効？│
   │                           ┌───────┴───────┐
   │                          YES             NO
   │                           │               │
   │                           ▼               ▼
   │                      処理継続         401 返却
   │                           │
   │  200 OK                   │
   │<──────────────────────────│
```

### トークンリフレッシュの処理フロー

```
Client                              Server
   │                                   │
   │  GET /tasks (期限切れトークン)     │
   │──────────────────────────────────>│
   │                                   │
   │  401 Unauthorized                 │
   │<──────────────────────────────────│
   │                                   │
   │  POST /auth/refresh               │
   │  Cookie: refreshToken=xxx         │
   │──────────────────────────────────>│
   │                                   │
   │                          ┌────────┴────────┐
   │                          │ refreshService   │
   │                          │ 1. JWTの検証     │
   │                          │ 2. DBの値と照合   │
   │                          └────────┬────────┘
   │                                   │
   │                              有効？│
   │                           ┌───────┴───────┐
   │                          YES             NO
   │                           │               │
   │                           ▼               ▼
   │                    新トークン生成     401 返却
   │                    ・accessToken      （再ログイン必要）
   │                    ・refreshToken
   │                    （ローテーション）
   │                           │
   │                    DBに新トークン保存
   │                           │
   │  200 OK                   │
   │  Set-Cookie: token=xxx    │
   │  Set-Cookie: refreshToken │
   │<──────────────────────────│
   │                                   │
   │  GET /tasks (新トークン)           │
   │──────────────────────────────────>│
   │                                   │
   │  200 OK                           │
   │<──────────────────────────────────│
```

### ログアウトの処理

```
POST /auth/logout
    │
    ▼
┌─────────────────────────────────┐
│  DBのリフレッシュトークンを削除   │
│  (User.refreshToken = null)     │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  cookie をクリア                 │
│  ・token                        │
│  ・refreshToken                 │
└─────────────────────────────────┘
    │
    ▼
レスポンス: { success: true, data: { message: "ログアウトしました" } }
```

### トークンローテーション

リフレッシュ時に新しいリフレッシュトークンも発行する（ローテーション）。

リフレッシュトークンは DB（User.refreshToken）に保存され、リフレッシュ時に DB の値と照合される。これにより：

- 古いトークンはリフレッシュ後に無効化される
- ログアウト時にトークンを即座に無効化できる
- トークン漏洩時にログアウトで対処可能
